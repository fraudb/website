<h2>How does FrauDB work?</h2>
<p>On a practical level, FrauDB does two things: allow the listing of fraudulent users in its database and allow the checking of data against that database. Essentially, if a member flags one of their customers for violating their terms and conditions or just being a pain for support staff, they can report that user to FrauDB and if the report goes through that user's email address and any other identifying information will first be hashed by the reportee and then sent in the hashed format to FrauDB. Now if another member has that same user sign up on their website, they can check all the identifying information the user has entered against FrauDB's database by, again, hashing that data first and then querying the database for whether the same hash exists in the database. If it does exist, then the user is considered "listed" and the member can choose how to proceed, which they might do in a variety of ways including:</p>
<ul>
    <li>Blocking the user from signing up.</li>
    <li>Triggering an ID verification process.</li>
    <li>Restricting the account's access permissions.</li>
    <li>e.t.c.</li>
</ul>
<p>In the scope of the whole of the member list of FrauDB, only one has to realise that a user is a bad apple for the entire member list to be able to preemptively restrict that user from their platform, without even knowing they got listed!</p>
<h2>Storing user data</h2>
<p>This concept might seem dangerous to some of those reading this, especially folk from the legal sector, but sure enough we found a way to do all of this securely and more importantly in a legal and private fashion.</p>
<p>To begin with, we use hashing. Now a hash is like a one-way ticket to obscurity, it's a cryptographic function that takes some data as its argument and it's output will be a value of fixed length that is <strong>practically impossible to reverse</strong>. Think of how easy it is to multiply two prime numbers together, like 53 and 97 to get 5,141. Now try to gather what two numbers we multiplied together to get 5,141 as the output. Not so easy? That's how a cryptographic hash function works at a fundamental level, just scaled up a LOT.</p>
<p>To demonstrate how hard it is to reverse a SHA256 hash, please enjoy this video by the incredibly smart 3blue1brown</p>
<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/S9JGmA5_unY" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<p>But what does this mean for us? Simply because we store all submitted data in its hashed format, we will never have a faster way of knowing who is listed in our database than just guessing or brute-forcing the checking mechanism. And that mechanism is locked behind a heavy rate-limit for anyone else than the members that make up our organisation. And the best part is that even if you did guess an email address that is listed, you would not get the rest of that user's identifying information. All you'd get is just a "Yes" or "No" answer to whether that specific hash is listed in the database. That's it, that's how simple it is.</p>
<p>Tl;DR: Even if our database was publicly readable by the whole world, which it isn't by the way, the data contained would be so useless that it might as well have been generated by a machine.</p>
<h2>Data spillage (zero-logs-policy)</h2>
<p>While the way data is stored is crucially important, it makes no difference if all that data is "leaked" in our log files, e.t.c. Thankfully we've thought of this and combat this in two ways:</p>
<h3>Only hashed submissions</h3>
<p>To submit any data at all, the contents of that data must be hashed. Our backend software checks for whether any data submitted for listing is in the format of a SHA256 hash and if it isn't it will reject the request.</p>
<p>You can verify that this is what happens by looking at our source code on <a href="https://github.com/fraudb/query-backend" class="link" target="_blank" rel="noreferrer">GitHub</a>.</p>
<h3>Zero-logs-policy</h3>
<p>You hear this from every VPN company in the world, and sadly it's often not true, but the difference between private VPN enterprises and FrauDB is that FrauDB is a free, open and public service owned by its members. All of the source code of FrauDB is published on GitHub, including the Nginx configuration files for the backend APIs & e.t.c.</p>
<p>You can verify our commitment to zero-logging by looking at our source code on <a href="https://github.com/fraudb/nginx-configuration" class="link" target="_blank" rel="noreferrer">GitHub</a>.</p>
<h2>Data integrity</h2>
<p>To make sure data is never lost or damaged, we run the PostreSQL database backend in a replicated setup across several host machines all located in countries who are havens for privacy like Iceland or Switzerland. One of our hosts is even <a href="#" class="link" target="_blank" rel="noreferrer">located in a bunker</a>!</p>
<p>In addition to this, we have backups taken across the world with hilariously frequent syncing, so that even a total wipe of all our operational host machines can be restored within seconds to a backup network.</p>
<h2>Tagging</h2>
<p>Every listing submitted to the database is tagged with one or more tags from our <a href="https://docs.fraudb.org/tags/list" class="link" target="_blank" rel="noreferrer">list of tags</a>. This means that if one member of ours submits a listing for a customer that has been taking advantage of their service for e.g. hosting websites on the TOR network against the provider's will, then when that user goes to sign up for a forum that's also a member of ours, they won't be blocked or flagged because the forum owner is only checking for tags relevant to violating rules of internet communities (like forums, IRC channels or Discord servers).</p>